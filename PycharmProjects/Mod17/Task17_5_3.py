"""
Модифицируйте алгоритм Дейкстры таким образом, что в массив P
по соответствующему ключу будет записываться предок с минимальным
расстоянием, если это необходимо.
"""

G = {"Адмиралтейская": {"Садовая": 4},
     "Садовая":
         {"Сенная площадь": 3,
          "Спасская": 3,
          "Адмиралтейская": 4,
          "Звенигородская": 5},
     "Сенная площадь":
         {"Садовая": 3,
          "Спасская": 3},
     "Спасская":
         {"Садовая": 3,
          "Сенная площадь": 3,
          "Достоевская": 4},
     "Звенигородская":
         {"Пушкинская": 3,
          "Садовая": 5},
     "Пушкинская":
         {"Звенигородская": 3,
          "Владимирская": 4},
     "Владимирская":
         {"Достоевская": 3,
          "Пушкинская": 4},
     "Достоевская":
         {"Владимирская": 3,
          "Спасская": 4}}

D = {k: 100 for k in G.keys()}  # расстояния
start_k = 'Адмиралтейская'  # стартовая вершина
D[start_k] = 0  # расстояние от нее до самой себя равно нулю
U = {k: False for k in G.keys()}  # флаги просмотра вершин
P = {k: None for k in G.keys()}  # предки

for _ in range(len(D)):
    # выбираем среди непросмотренных наименьшее по расстоянию
    min_k = min([k for k in U.keys() if not U[k]], key=lambda x: D[x])

    for v in G[min_k].keys():  # проходимся по всем смежным вершинам
        if D[v] > D[min_k] + G[min_k][v]:  # если расстояние от текущей вершины меньше
            D[v] = D[min_k] + G[min_k][v]  # то фиксируем его
            P[v] = min_k  # и записываем как предок
    U[min_k] = True  # просмотренную вершину помечаем

pointer = 'Владимирская'  # куда должны прийти
while pointer is not None:  # перемещаемся, пока не придём в стартовую точку
    print(pointer)
    pointer = P[pointer]
